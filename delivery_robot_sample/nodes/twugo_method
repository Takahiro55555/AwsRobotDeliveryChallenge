#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

# Copy right 2020 Takuya TWUGO all right reseved

#
# This node enable you to control robot moving velocity from cloud using AWS IoT.
#
# このノードは トゥーグーメソッドでできています
# 

import rospy
import json
from geometry_msgs.msg import Twist
from std_msgs.msg import String
from nav_msgs.msg import Odometry
import time
import tf
from geometry_msgs.msg import Vector3
import math

LINERAR_SPEED = 0.22
LINEAR_STEP = 0.1 / 3
ANGULER_SPEED = 2.84
ANGULER_STEP = 0.5 / 3

class TwugoMethod():
    def __init__(self):
        # self._cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self._odom_sub = rospy.Subscriber("/odom", Odometry, self.odom_cb, queue_size=1)
        self.twist = Twist()
        self.next_synctime = time.time()
        self.is_moving = False
        self.action = ""
        self.xg = 3.1411
        self.yg = 0.2866
        

    def main(self):
        while not rospy.is_shutdown():
            if not self.is_moving:
                time.sleep(0.3)
                continue

            while not rospy.is_shutdown():
                d = self.next_synctime - time.time()
                if d <= 0:
                    break
                time.sleep(d) 
                
            # if self.is_moving:
            #     self.sync_action()

    def odom_cb(self, data):
        r_x, r_y = data.pose.pose.position.x, data.pose.pose.position.y
        r_ang = tf.transformations.euler_from_quaternion([data.pose.pose.orientation.x, data.pose.pose.orientation.y, data.pose.pose.orientation.z, data.pose.pose.orientation.w])
        # rospy.loginfo("Robot angle: %f" % math.degrees(r_ang[2]))
        # g_ang = tf.transformations.quaternion_from_euler(0.0, 0.0, math.atan2(self.yg - r_y, self.xg - r_x))
        # diff_ang = g_ang - data.pose.pose.orientation
        # rospy.loginfo("Relative goal angle: %f" % math.degrees(tf.transformations.euler_from_quaternion(g_ang)))
        # # rospy.loginfo("Relative diff angle: %f" % math.degrees(g_ang - r_ang[2]))
        # rospy.loginfo("Relative diff angle: %f" % math.degrees(tf.transformations.euler_from_quaternion(diff_ang)))
        
        ang_diff = self.sign(math.atan2(self.yg - r_y, self.xg - r_x)) * (math.atan((self.yg - r_y)/(self.xg - r_x)) - r_ang[2])
        rospy.loginfo("Relative diff angle: %f, Relative goal angle: %s" % (math.degrees(ang_diff), math.degrees(math.atan((self.yg - r_y)/(self.xg - r_x)))))

    @staticmethod
    def sign(x):
        return (x > 0) - (x < 0)



    # def sync_action(self):
    #     if self.action == 'forward':
    #         self.twist.linear.x = min([LINERAR_SPEED, self.twist.linear.x + LINEAR_STEP])
    #         self.is_moving = True
    #     elif self.action == 'backward':
    #         self.twist.linear.x = max([-LINERAR_SPEED, self.twist.linear.x - LINEAR_STEP])
    #         self.is_moving = True
    #     elif self.action == 'right':
    #         self.twist.angular.z = max([-ANGULER_SPEED, self.twist.angular.z - ANGULER_STEP])
    #         self.is_moving = True
    #     elif self.action == 'left':
    #         self.twist.angular.z = min([ANGULER_SPEED, self.twist.angular.z + ANGULER_STEP])
    #         self.is_moving = True
    #     if self.action == 'stop' or self.action == 'right' or self.action == 'left':
    #         if self.twist.linear.x > 0:
    #             self.twist.linear.x = max([0, self.twist.linear.x - LINEAR_STEP])
    #         elif self.twist.linear.x < 0:
    #             self.twist.linear.x = min([0, self.twist.linear.x + LINEAR_STEP])
    #     if self.action == 'stop' or self.action == 'forward' or self.action == 'backward':
    #         if self.twist.angular.z > 0:    
    #             self.twist.angular.z = max([0, self.twist.angular.z - ANGULER_STEP])
    #         elif self.twist.angular.z < 0:    
    #             self.twist.angular.z = min([0, self.twist.angular.z + ANGULER_STEP])
            
    #     self.next_synctime = time.time() + 0.3
    #     self._cmd_pub.publish(self.twist)
        
    #     if self.twist.linear.x == 0 and self.twist.angular.z == 0:
    #         self.is_moving = False
        
def main():
    rospy.init_node('twugo_method')
    remote_controller = TwugoMethod()
    remote_controller.main()        

if __name__ == '__main__':
    main()
