#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# このノードは navigation スタックへの操作を経路ファイルから行います
#

import rospy
import json
from std_msgs.msg import String
from nav_msgs.msg import Odometry
from rosgraph_msgs.msg import Log
import heapq
import itertools


def main():
    rospy.init_node('planner')
    planner = Planner()
    planner.main()

class Planner():
    def __init__(self):
        # self._odom_sub = rospy.Subscriber(
        #     "/odom", Odometry, self.odom_cb, queue_size=1)
        # self._awsiot_to_ros_pub = rospy.Publisher(
        #     "/awsiot_to_ros", String, queue_size=1)
        # self._twugo_method_pub = rospy.Publisher(
        #     "/twugo_method", String, queue_size=1)

        self.__vertex_list_param = rospy.get_param("/vertex_list")
        self.__init_graph()  # __vertex_list_param から Vertex と Edge を作成
        self.__shortest_path_dict = {}

    def main(self):
        self.__calc_all_patterns()
        rospy.spin()

    def __init_graph(self):
        # Vertex を生成
        self.__vertex_list = []
        vertex_dict = {}  # NOTE: __vertex_list_param のインデックスと vertex_id が一致する保証はないため
        for v in self.__vertex_list_param:
            if v["id"] in vertex_dict:
                rospy.logwarn("[Class: %s]: vertex id:%d is already exists" % (self.__class__.__name__, v["id"]))
            vertex = Vertex(v["id"], v["x"], v["y"], v["is_destination"])
            self.__vertex_list.append(vertex)
            vertex_dict[v["id"]] = vertex
        self.__destination_num = len([x for x in self.__vertex_list if x.get_is_destination()])

        # Vertex を Edge で繋ぐ
        FLAG_STR = "%d-%d"
        linked_vertex_flag = dict()
        for v in self.__vertex_list_param:
            for lv in v["linked_vertex_list"]:
                key = FLAG_STR % (v["id"], lv)
                if key in linked_vertex_flag:
                    continue
                # NOTE: __vertex_list_param のインデックスと vertex_id が一致する保証はないため
                #       vertex_id　から当該 Vertex を確実に取得できる vertex_dict を利用する
                Edge(vertex_dict[v["id"]], vertex_dict[lv])
                linked_vertex_flag[key] = True
                key = FLAG_STR % (lv, v["id"])
                linked_vertex_flag[key] = True

    def __calc_all_patterns(self, start_vertex_id=0):
        destination_id_list = []
        start_vertex = None
        # 目的地となるvertex_idを取得する
        for vertex in self.__vertex_list:
            if vertex.get_is_destination():
                self.__dijkstra_planner(vertex)
                vertex_id = vertex.get_vertex_id()
                if vertex_id != start_vertex_id:
                    destination_id_list.append(vertex_id)
                else:
                    start_vertex = vertex
        # すべての巡回経路を算出
        all_patterns = map(list, itertools.permutations(destination_id_list))
        mini_cost = float("inf")
        mini_cost_path = None
        # 最小となる巡回経路を算出する
        for path in all_patterns:
            p = start_vertex_id
            tmp_cost = 0
            for c in path:
                key = "%d-%d" % (p, c)
                p = c
                tmp_cost += self.__shortest_path_dict[key]["cost"]
            if mini_cost > tmp_cost:
                mini_cost = tmp_cost
                mini_cost_path = path

        p = start_vertex_id
        full_path = [start_vertex]
        for c in mini_cost_path:
            key = "%d-%d" % (p, c)
            p = c
            half_path = self.__shortest_path_dict[key]["path"]
            if half_path[0].get_vertex_id() == c:
                half_path.reverse()
            full_path.extend(half_path[1:])
        rospy.loginfo("Destination path: %s" % mini_cost_path)
        rospy.loginfo("Full path: %s" % map(lambda x: x.get_vertex_id(), full_path))
        return full_path

    def __dijkstra_planner(self, start_vertex):

        # vertexごとのSTARTからの最小コスト
        min_dist_dict = {}
        min_dist_dict[start_vertex] = 0
        # vertexに最小コストで辿り着く場合の直前のノード
        prev_vertex_dict = {}
        prev_vertex_dict[start_vertex] = ''
        queue = []
        # START vertex をキューにプッシュ
        heapq.heappush(queue, start_vertex)
        arrived_destination = []
        arrived_destination.append(start_vertex)

        while True:
            # 確定した vertex から遷移可能な vertex のうち
            # 最小コストと遷移先ノードを min_dist_dict と prev_node_dict に設定
            vertex = heapq.heappop(queue)

            # GOAL
            if vertex.get_is_destination():
                # goalノードには複数回行くことがあるのでリストとか作ってlength使う?
                if not vertex in arrived_destination:
                    path = []
                    tmp_vertex = vertex
                    while True:
                        path.append(tmp_vertex)
                        if tmp_vertex.get_vertex_id() == start_vertex.get_vertex_id():
                            break
                        tmp_vertex = prev_vertex_dict[tmp_vertex]
                    result = {
                        "cost": min_dist_dict[vertex],
                        "path": path
                    }
                    key = "%d-%d" % (path[0].get_vertex_id(), path[-1].get_vertex_id())
                    self.__shortest_path_dict[key] = result
                    key = "%d-%d" % (path[-1].get_vertex_id(), path[0].get_vertex_id())
                    self.__shortest_path_dict[key] = result
                    arrived_destination.append(vertex)
                    if(len(arrived_destination) >= self.__destination_num):
                        return

            prev_vertex = vertex
            # 確定したノードから遷移可能な vertex について
            # コストを計算し、キューに追加する
        
            # 直前に確定した vertex から遷移可能な edge について繰り返し
            for arrival_edge in prev_vertex.get_edge_list():
                # 遷移可能なvertexについて、直前に確定したvertexから遷移した場合のコストを計算
                tmp_d = min_dist_dict[prev_vertex] + arrival_edge.get_cost()
                arrival_vertex = arrival_edge.get_opposite_vertex(prev_vertex)
                # 過去に遷移先ノードの最小コストを計算済みかどうか
                if arrival_vertex in min_dist_dict.keys():
                    # 過去に計算していたSTARTからの最小コストより直前に確定したノードから遷移した場合の
			        # コストが小さかった場合，最小コストを更新
                    if tmp_d < min_dist_dict[arrival_vertex]:
                        min_dist_dict[arrival_vertex] = tmp_d
                        heapq.heappush(queue, arrival_vertex)
                        prev_vertex_dict[arrival_vertex] = prev_vertex
                else:
                    min_dist_dict[arrival_vertex] = tmp_d
                    heapq.heappush(queue, arrival_vertex)
                    prev_vertex_dict[arrival_vertex] = prev_vertex

    def _iot_command_cb(self, payload):
        if "command" in payload and "action" in payload and "request_id" in payload:
            if payload["command"] == "game" and payload["action"] == "start":
                rospy.loginfo("detect start!!")
                self._is_started = True
                self._is_sended = False
                self._is_goal = False
                self._current_step = 0

    def odom_cb(self, data):
        try:
            payload = {}
            if self._is_goal:
                return
            if not self._is_started:
                return
            if not self._is_sended:
                payload["x"] = rospy.get_param("/step")[self._current_step]["x"]
                payload["y"] = rospy.get_param("/step")[self._current_step]["y"]
                payload["is_goal"] = self._is_goal
                self._twugo_method_pub.publish(json.dumps(payload))
                self._is_sended = True
            s_x, s_y = rospy.get_param("/step")[self._current_step]["x"], rospy.get_param("/step")[self._current_step]["y"]
            r_x, r_y = data.pose.pose.position.x, data.pose.pose.position.y
            error = ((r_x - s_x)**2 + (r_y - s_y)**2)
            
            if error < rospy.get_param("/step")[self._current_step]["tolerance"]**2:
                self._current_step += 1
                self._is_sended = False
                rospy.loginfo("Current step: %d" % self._current_step)
                if len(rospy.get_param("/step")) <= self._current_step:
                    self._is_goal = True
                    payload["is_goal"] = self._is_goal
                    self._twugo_method_pub.publish(json.dumps(payload))
                    rospy.loginfo("Is Goal!!!!!!!!")

        except Exception as e:
            rospy.logwarn("command publisher request failed")
            rospy.logwarn(e)


class Vertex:
    def __init__(self, vertex_id, x, y, is_destination=False):
        self.__edge_list = []  # 
        self.__x = x
        self.__y = y
        self.__is_destination = is_destination
        self.__vertex_id = vertex_id
    
    def set_edge(self, edge):
        if edge in self.__edge_list:
            return
        self.__edge_list.append(edge)

    def get_position(self):
        return self.__x, self.__y

    def get_is_destination(self):
        return self.__is_destination
    
    def get_edge_list(self):
        return self.__edge_list
    
    def get_vertex_id(self):
        return self.__vertex_id


class Edge:
    def __init__(self, vertex_a, vertex_b):
        self.__vertex_list = [vertex_a, vertex_b]
        self.__cost = self.__calc_cost()
        vertex_a.set_edge(self)
        vertex_b.set_edge(self)

    def get_opposite_vertex(self, my_vertex):
        if not my_vertex in self.__vertex_list:
            return None
        for v in self.__vertex_list:
            if v is my_vertex:
                continue
            return v

    def __calc_cost(self):
        ax, ay = self.__vertex_list[0].get_position()
        bx, by = self.__vertex_list[1].get_position()
        return ((ax - bx)**2 + (ay - by)**2)**0.5

    def get_cost(self):
        return self.__cost


if __name__ == '__main__':
    main()